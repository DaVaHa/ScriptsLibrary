Forecasting in R

### Exploring and visualizing time series in R ###

# Create "ts" (time series) object
# Read the data from Excel into R
mydata <- read_excel("exercise1.xlsx")
# Look at the first few lines of mydata
head(mydata)
# Create a ts object called myts
myts <- ts(mydata[,2:4], start = c(1981, 1), frequency = 4)

#datasets in forecast package
gold  : containing gold prices in US dollars
woolyrnq : containing information on the production of woollen yarn in Australia
gas : containing Australian gas production

# Plot the data with facetting
autoplot(myts, facets = TRUE)
# Plot the data without facetting
autoplot(myts, facets = FALSE)
# Plot the three series
autoplot(gold)
autoplot(woolyrnq)
autoplot(gas)
# Find the outlier in the gold series
goldoutlier <- which.max(gold)
# Look at the seasonal frequencies of the three series
frequency(gold)
frequency(woolyrnq)
frequency(gas)

# Load the fpp2 package
library("fpp2")
# Create plots of the a10 data
autoplot(a10)
ggseasonplot(a10)
# Produce a polar coordinate season plot for the a10 data
ggseasonplot(a10, polar = TRUE)
# Restrict the ausbeer data to start in 1992
beer <- window(ausbeer, start = 1992)
# Make plots of the beer data
autoplot(beer)
ggsubseriesplot(beer)

# The correlations associated with the lag plots form 
# what is called the autocorrelation function (ACF). 
# The ggAcf() function produces ACF plots.
# Create an autoplot of the oil data
autoplot(oil)
# Create a lag plot of the oil data
gglagplot(oil, 1)
# Create an ACF plot of the oil data
ggAcf(oil)


# Plot the annual sunspot numbers
autoplot(sunspot.year)
ggAcf(sunspot.year)
# Save the lag corresponding to maximum autocorrelation
maxlag_sunspot <- 1
# Plot the traffic on the Hyndsight blog
autoplot(hyndsight)
ggAcf(hyndsight)
# Save the lag corresponding to maximum autocorrelation
maxlag_hyndsight <- 7

# White noise = time series that is purely random
# We can test for white noise by looking at an ACF plot or by doing a Ljung-box test
# A p-value greater than 0.05 suggests the data are not significantly different from white noise
set.seed(3) 		# reproducibility
wn <- ts(rnorm(36)) # white noise
autoplot(wn) 		# plot
ggAcf(wn) + ggtitle("Sample ACF for White Noise") 
# Expectation : each correlation is close to zero
# 95 % of all autocorrelations for white noise should lie within the blue lines
# if not : series is probably not white noise

# Ljung-box test :  considers the first "h" autocorrelation values together
# A significant test (small p-value) indicates the data are probably not white noise
Box.test(pigs, lag = 24, fitdf = 0, type ="Lj")
# Plot the original series
autoplot(goog)
# Plot the differenced series
autoplot(diff(goog))
# ACF of the differenced series
ggAcf(diff(goog))
# Ljung-Box test of the differenced series
Box.test(diff(goog), lag = 10, type = "Ljung")



### Benchmark methods and forecast accuracy ###

# a forecast is the mean or median of simulated futures of a time series

# Naive forecast : use most recent observation - naive() (= useful benchmark)
# Naive (incl season) : snaive()

# Use naive() to forecast the goog series
fcgoog <- naive(goog, 20)
# Plot and summarize the forecasts
autoplot(fcgoog)
summary(fcgoog)

# Use snaive() to forecast the ausbeer series
fcbeer <- snaive(ausbeer, 16)
# Plot and summarize the forecasts
autoplot(fcbeer)
summary(fcbeer)

# residuals = forecast errors

fc <- naive(oil)
autoplot(oil, series = "Data") + xlab("Year") +
 autolayer(fitted(fc), series = "Fitted") + 
 ggtitle("Oil production in Saudi Arabia")

# Residuals should look like white noise
autoplot(residuals(fc))
 
# Assumptions : uncorrelated, mean = zero, constant variance, normally distributed 
checkresiduals()

# Check the residuals from the naive forecasts applied to the goog series
goog %>% naive() %>% checkresiduals()
# Do they look like white noise (TRUE or FALSE)
googwn <- TRUE
# Check the residuals from the seasonal naive forecasts applied to the ausbeer series
ausbeer %>% snaive() %>% checkresiduals()
# Do they look like white noise (TRUE or FALSE)
beerwn <- FALSE

# Test set must not be used for any aspect of calculating forecast
# Build forecasts using training set
# A model which fits the training data well will not necessarily forecast well
training <- window(oil, end = 2003)
test <- window(oil, start = 2004)
fc <- naive(training, h = 10)
autoplot(fc) + autolayer(test, series = "Test data")

# Forecast = mean of all observations
meanf()

# Forecast error = difference between observed value and its forecast in the test set (!= residuals)
# residuals = errors on training set (vs test set) and based on one-step forecasts (vs multi-step)
# Compute accuracy using forecast errors on test data

# Measures of forecast accuracy : the smaller the better
# MAE = Mean Absolute Error
# MSE = Mean Squared Error
# RMSE = Root Mean Squared Error
# MAPE = Mean Absolute Percentage Error
# MASE = Mean Absolute Scaled Error
accuracy(fc, test)

# Create the training data as train
train <- subset(gold, end = 1000)
# Compute naive forecasts and save to naive_fc
naive_fc <- naive(train, h = 108)
# Compute mean forecasts and save to mean_fc
mean_fc <- meanf(train, h = 108)
# Use accuracy() to compute RMSE statistics
accuracy(naive_fc, gold)
accuracy(mean_fc, gold)
# Assign one of the two forecasts as bestforecasts
bestforecasts <- naive_fc

# Create three training series omitting the last 1, 2, and 3 years
train1 <- window(vn[, "Melbourne"], end = c(2014, 4))
train2 <- window(vn[, "Melbourne"], end = c(2013, 4))
train3 <- window(vn[, "Melbourne"], end = c(2012, 4))
# Produce forecasts using snaive()
fc1 <- snaive(train1, h = 4)
fc2 <- snaive(train2, h = 4)
fc3 <- snaive(train3, h = 4)
# Use accuracy() to compare the MAPE of each series
accuracy(fc1, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc2, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc3, vn[, "Melbourne"])["Test set", "MAPE"]

# time series cross validation : tsCV()
# With no parameters to be estimated, tsCV with h=1 will give same values as residuals
e <- tsCV(oil, forecastfunction = naive, h = 1)
mean(e^2, na.rm = TRUE)

# MSE increases with forecast horizon
sq <- function(u){u^2}
for (h in 1:10) { 
 oil %>% tsCV(forecastfunction = naive, h = h) %>%
	sq() %>% mean(na.rm = TRUE) %>% print()
}

# Compute cross-validated errors for up to 8 steps ahead
e <- tsCV(goog, forecastfunction = naive, h = 8)
# Compute the MSE values and remove missing values
mse <- colMeans(e^2, na.rm = TRUE)
# Plot the MSE values against the forecast horizon
data.frame(h = 1:8, MSE = mse) %>%
  ggplot(aes(x = h, y = MSE)) + geom_point()
  







